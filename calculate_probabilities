def no_existential_quantifier(UCQ,quantifier):
    #Check if the none of the variables in the UCQ are existential in quantifier dict.
def test(UCQ):
   for value in UCQ:
       try:
           float(value)
       except ValueError:
           return True
   return False
def isUCQ(UCQ):
   if type(UCQ) is list:
       return True
   elif type(UCQ) is dict:
       return False
def check_Independence_UCQ(
       tables):  # Check independence across entire UCQ, i.e. no repeating table names
   temp = set()
   for cq in range(0, len(tables)):
       if not temp.isdisjoint(tables[cq]):
           return False
       temp = temp | tables[cq]
   return True
def check_Independence_CQ(cq):  # check independence within a CQ
   tables = set()
   for clause in cq:
       if (cq[clause].get("name") in tables):
           return False;
       tables.add(cq[clause].get("name"))
   return True
def getProbability(UCQ):

    return 0.5
def parse_UCQ(input_query):
   UCQ = []
   quantifier = {}
   UCQ_list = input_query.split("||")  # split into individual conjunctions
   tables = []  # Represent all tables in each CQ
   for cq in UCQ_list:  # iterate through the above list, cq is each conjunction
       cq = cq.strip()  # remove spaces
       list_cq = cq.split(
           "),")  # to get list of relations. splitting by ), instead of , to ensure that it splits two relations and not withing a single relation
       dict_cq = {}  # dictionary representing each conjunctive clause
       temp_tables = set()
       for q in list_cq:  # iterate through the relations within each conjunctive clause
           q = q.strip()  # remove spaces
           q = q.split("(")  # splitting by ( will ensure that the first index in the list is table name and second is variables
           temp_list = q[1].strip("").replace(")", "").split(",")  # remove spaces, remove the ) at the endd, and split by comma to get a list of variables
           temp_tables.add(q[0])
           for var in temp_list:  # set the quantifier value as existential for all variables
               quantifier[var] = 1
           dict_cq[q[0]] = temp_list  # append relation dictionary to the conjunctive clause dictionary
       UCQ.append(
           dict_cq)  # append conjunctive clause dictionary to the list of union of conjunctive clauses
       tables.append(temp_tables)
   return UCQ, quantifier, tables
def probability(UCQ, quantifiers, tables):
   # Base of recursion
   if len(UCQ)==1 and no_existential_quantifier(UCQ,quantifier):
       return getProbability(UCQ[0])
   # decomposable disjunction
   # elif isUCQ(UCQ):
   #     if check_Independence_UCQ(tables):
   #         val1 = 1 - probability(UCQ[0], quantifier, tables)
   #         val2 = 1 - probability(UCQ[1], quantifier, tables)
   #         return 1 - val1 * val2
   # # decomposable conjunction
   # elif check_Independence_CQ(UCQ):
   #     val1 = probability(UCQ[0], quantifier, tables)
   #     val2 = probability(UCQ[1], quantifier, tables)
   #     return val1 * val2
input_query = "S(x)"
UCQ, quantifier, tables = parse_UCQ(input_query)
print(UCQ)
print(quantifier)
print(tables)
print(probability(UCQ,quantifier,tables))
probabilities={'S':[0.8,0.2,0.1]}
